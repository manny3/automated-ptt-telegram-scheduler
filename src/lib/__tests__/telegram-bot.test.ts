import axios from 'axios'
import {
  TelegramBotClient,
  TelegramBotError,
  formatArticleForTelegram,
  formatArticlesForTelegram,
  splitLongMessage,
  groupArticlesForMessages,
  sendArticlesToTelegram,
  testTelegramBot
} from '../telegram-bot'
import { PTTArticle } from '@/types'

// Mock axios
jest.mock('axios')
const mockedAxios = axios as jest.Mocked<typeof axios>

describe('Telegram Bot Integration', () => {
  let telegramClient: TelegramBotClient

  const mockArticles: PTTArticle[] = [
    {
      title: '[ÂæµÊâç] Python ÂæåÁ´ØÂ∑•Á®ãÂ∏´',
      author: 'testuser1',
      date: '12/25',
      link: 'https://www.ptt.cc/bbs/Tech_Job/M.1234567890.A.123.html',
      board: 'Tech_Job'
    },
    {
      title: '[ÂøÉÂæó] Èù¢Ë©¶Á∂ìÈ©óÂàÜ‰∫´',
      author: 'testuser2',
      date: '12/24',
      link: 'https://www.ptt.cc/bbs/Tech_Job/M.1234567891.A.124.html',
      board: 'Tech_Job'
    }
  ]

  beforeEach(() => {
    jest.clearAllMocks()
    telegramClient = new TelegramBotClient('test-token', true) // ‰ΩøÁî®Ê∏¨Ë©¶Ê®°Âºè
  })

  describe('formatArticleForTelegram', () => {
    it('ÊáâË©≤Ê≠£Á¢∫Ê†ºÂºèÂåñÂñÆÁØáÊñáÁ´†', () => {
      const article = mockArticles[0]
      const formatted = formatArticleForTelegram(article)

      expect(formatted).toContain('üì∞ **[ÂæµÊâç] Python ÂæåÁ´ØÂ∑•Á®ãÂ∏´**')
      expect(formatted).toContain('üë§ ‰ΩúËÄÖÔºötestuser1')
      expect(formatted).toContain('üìÖ Êó•ÊúüÔºö12/25')
      expect(formatted).toContain('üìã ÁúãÊùøÔºöTech_Job')
      expect(formatted).toContain('üîó ÈÄ£ÁµêÔºöhttps://www.ptt.cc/bbs/Tech_Job/M.1234567890.A.123.html')
    })
  })

  describe('formatArticlesForTelegram', () => {
    it('ÊáâË©≤Ê≠£Á¢∫Ê†ºÂºèÂåñÂ§öÁØáÊñáÁ´†', () => {
      const formatted = formatArticlesForTelegram(mockArticles, 'Tech_Job')

      expect(formatted).toContain('üìã **Tech_Job** ÁúãÊùøÊúÄÊñ∞ÊñáÁ´† (2 ÁØá)')
      expect(formatted).toContain('1. **[ÂæµÊâç] Python ÂæåÁ´ØÂ∑•Á®ãÂ∏´**')
      expect(formatted).toContain('2. **[ÂøÉÂæó] Èù¢Ë©¶Á∂ìÈ©óÂàÜ‰∫´**')
      expect(formatted).toContain('üë§ testuser1 | üìÖ 12/25')
      expect(formatted).toContain('üë§ testuser2 | üìÖ 12/24')
    })

    it('ÊáâË©≤ËôïÁêÜÁ©∫ÊñáÁ´†Èô£Âàó', () => {
      const formatted = formatArticlesForTelegram([], 'Tech_Job')

      expect(formatted).toBe('üìã **Tech_Job** ÁúãÊùøÁõÆÂâçÊ≤íÊúâÁ¨¶ÂêàÊ¢ù‰ª∂ÁöÑÊñáÁ´†')
    })
  })

  describe('splitLongMessage', () => {
    it('ÊáâË©≤‰øùÊåÅÁü≠Ë®äÊÅØ‰∏çËÆä', () => {
      const shortMessage = 'ÈÄôÊòØ‰∏ÄÂâáÁü≠Ë®äÊÅØ'
      const result = splitLongMessage(shortMessage, 100)

      expect(result).toEqual([shortMessage])
    })

    it('ÊáâË©≤ÂàÜÂâ≤Èï∑Ë®äÊÅØ', () => {
      const longMessage = 'A'.repeat(5000)
      const result = splitLongMessage(longMessage, 4096)

      expect(result.length).toBeGreaterThan(1)
      expect(result[0].length).toBeLessThanOrEqual(4096)
    })

    it('ÊáâË©≤ÊåâË°åÂàÜÂâ≤Ë®äÊÅØ', () => {
      const message = 'Line 1\n' + 'B'.repeat(4090) + '\nLine 3'
      const result = splitLongMessage(message, 4096)

      expect(result.length).toBeGreaterThan(1)
      result.forEach(msg => {
        expect(msg.length).toBeLessThanOrEqual(4096)
      })
    })
  })

  describe('groupArticlesForMessages', () => {
    it('ÊáâË©≤Â∞áÊñáÁ´†ÂàÜÁµÑÁÇ∫ÈÅ©Áï∂Â§ßÂ∞èÁöÑË®äÊÅØ', () => {
      const manyArticles = Array.from({ length: 10 }, (_, i) => ({
        ...mockArticles[0],
        title: `[ÂæµÊâç] Â∑•Á®ãÂ∏´ËÅ∑‰Ωç ${i + 1}`,
        author: `user${i + 1}`
      }))

      const messages = groupArticlesForMessages(manyArticles, 'Tech_Job')

      expect(messages.length).toBeGreaterThan(1)
      messages.forEach(message => {
        expect(message.length).toBeLessThanOrEqual(4096)
      })
    })

    it('ÊáâË©≤ËôïÁêÜÁ©∫ÊñáÁ´†Èô£Âàó', () => {
      const messages = groupArticlesForMessages([], 'Tech_Job')

      expect(messages).toEqual(['üìã **Tech_Job** ÁúãÊùøÁõÆÂâçÊ≤íÊúâÁ¨¶ÂêàÊ¢ù‰ª∂ÁöÑÊñáÁ´†'])
    })
  })

  describe('TelegramBotClient', () => {
    describe('sendMessage', () => {
      it('ÊáâË©≤ÊàêÂäüÁôºÈÄÅË®äÊÅØ', async () => {
        mockedAxios.post.mockResolvedValueOnce({
          data: { ok: true, result: {} }
        })

        await telegramClient.sendMessage('123456789', 'Ê∏¨Ë©¶Ë®äÊÅØ')

        expect(mockedAxios.post).toHaveBeenCalledWith(
          'https://api.telegram.org/bottest-token/sendMessage',
          {
            chat_id: '123456789',
            text: 'Ê∏¨Ë©¶Ë®äÊÅØ',
            parse_mode: 'Markdown',
            disable_web_page_preview: true
          }
        )
      })

      it('ÊáâË©≤ËôïÁêÜÁÑ°ÊïàËÅäÂ§© ID ÈåØË™§', async () => {
        const error = {
          response: { 
            status: 400,
            data: { description: 'Bad Request: chat not found' }
          },
          message: 'Bad Request: chat not found'
        }
        mockedAxios.post.mockRejectedValueOnce(error)

        await expect(telegramClient.sendMessage('invalid', 'Ê∏¨Ë©¶Ë®äÊÅØ'))
          .rejects.toThrow('ÁÑ°ÊïàÁöÑËÅäÂ§© ID ÊàñË®äÊÅØÊ†ºÂºè')
      })

      it('ÊáâË©≤ËôïÁêÜ Bot Ë¢´Â∞ÅÈéñÈåØË™§', async () => {
        const error = {
          response: { 
            status: 403,
            data: { description: 'Forbidden: bot was blocked by the user' }
          },
          message: 'Forbidden: bot was blocked by the user'
        }
        mockedAxios.post.mockRejectedValueOnce(error)

        await expect(telegramClient.sendMessage('123456789', 'Ê∏¨Ë©¶Ë®äÊÅØ'))
          .rejects.toThrow('Bot Ë¢´Â∞ÅÈéñÊàñÊ≤íÊúâÁôºÈÄÅÊ¨äÈôê')
      })

      it('ÊáâË©≤ËôïÁêÜÈÄüÁéáÈôêÂà∂', async () => {
        const rateLimitError = {
          response: { 
            status: 429,
            data: { 
              description: 'Too Many Requests',
              parameters: { retry_after: 1 }
            }
          },
          message: 'Too Many Requests'
        }
        
        mockedAxios.post
          .mockRejectedValueOnce(rateLimitError)
          .mockResolvedValueOnce({ data: { ok: true, result: {} } })

        await telegramClient.sendMessage('123456789', 'Ê∏¨Ë©¶Ë®äÊÅØ')

        expect(mockedAxios.post).toHaveBeenCalledTimes(2)
      })

      it('ÊáâË©≤Âú®Á∂≤Ë∑ØÈåØË™§ÊôÇÈáçË©¶', async () => {
        mockedAxios.post
          .mockRejectedValueOnce(new Error('Network error'))
          .mockRejectedValueOnce(new Error('Network error'))
          .mockResolvedValueOnce({ data: { ok: true, result: {} } })

        await telegramClient.sendMessage('123456789', 'Ê∏¨Ë©¶Ë®äÊÅØ')

        expect(mockedAxios.post).toHaveBeenCalledTimes(3)
      })

      it('ÊáâË©≤Âú®ÈÅîÂà∞ÊúÄÂ§ßÈáçË©¶Ê¨°Êï∏ÂæåÂ§±Êïó', async () => {
        mockedAxios.post.mockRejectedValue(new Error('Network error'))

        await expect(telegramClient.sendMessage('123456789', 'Ê∏¨Ë©¶Ë®äÊÅØ'))
          .rejects.toThrow('ÁôºÈÄÅË®äÊÅØÂ§±ÊïóÔºåÁ∂ìÈÅé')
      })
    })

    describe('sendArticleBatch', () => {
      it('ÊáâË©≤ÊàêÂäüÁôºÈÄÅÊñáÁ´†ÊâπÊ¨°', async () => {
        mockedAxios.post.mockResolvedValue({ data: { ok: true, result: {} } })

        await telegramClient.sendArticleBatch('123456789', mockArticles, 'Tech_Job')

        expect(mockedAxios.post).toHaveBeenCalledTimes(1)
        const [url, payload] = mockedAxios.post.mock.calls[0]
        expect(url).toBe('https://api.telegram.org/bottest-token/sendMessage')
        expect(payload.chat_id).toBe('123456789')
        expect(payload.text).toContain('üìã **Tech_Job** ÁúãÊùøÊúÄÊñ∞ÊñáÁ´†')
      })

      it('ÊáâË©≤ËôïÁêÜÁ©∫ËÅäÂ§© ID', async () => {
        await expect(telegramClient.sendArticleBatch('', mockArticles, 'Tech_Job'))
          .rejects.toThrow('ËÅäÂ§©ÂÆ§ ID ‰∏çËÉΩÁÇ∫Á©∫')
      })

      it('ÊáâË©≤ËôïÁêÜÁ©∫ÊñáÁ´†Èô£Âàó', async () => {
        await telegramClient.sendArticleBatch('123456789', [], 'Tech_Job')

        expect(mockedAxios.post).not.toHaveBeenCalled()
      })

      it('ÊáâË©≤ÂàÜÂâ≤Â§ßÈáèÊñáÁ´†ÁÇ∫Â§öÂâáË®äÊÅØ', async () => {
        const manyArticles = Array.from({ length: 10 }, (_, i) => ({
          ...mockArticles[0],
          title: `[ÂæµÊâç] ÂæàÈï∑ÁöÑËÅ∑‰ΩçÊ®ôÈ°å ${i + 1}`.repeat(10),
          author: `user${i + 1}`
        }))

        mockedAxios.post.mockResolvedValue({ data: { ok: true, result: {} } })

        await telegramClient.sendArticleBatch('123456789', manyArticles, 'Tech_Job')

        // ÊáâË©≤ÂàÜÂâ≤ÁÇ∫Â§öÂâáË®äÊÅØÔºå‰ΩÜ‰∏ç‰∏ÄÂÆöÊòØÊØèÁØáÊñáÁ´†‰∏ÄÂâáË®äÊÅØ
        expect(mockedAxios.post).toHaveBeenCalledTimes(2)
      })
    })

    describe('testConnection', () => {
      it('ÊáâË©≤Âú®ÈÄ£Êé•ÊàêÂäüÊôÇËøîÂõû true', async () => {
        mockedAxios.post.mockResolvedValueOnce({ data: { ok: true, result: {} } })

        const result = await telegramClient.testConnection('123456789')

        expect(result).toBe(true)
        expect(mockedAxios.post).toHaveBeenCalledWith(
          'https://api.telegram.org/bottest-token/sendMessage',
          expect.objectContaining({
            chat_id: '123456789',
            text: 'ü§ñ Ê∏¨Ë©¶Ë®äÊÅØÔºöBot ÈÄ£Êé•Ê≠£Â∏∏ÔºÅ'
          })
        )
      })

      it('ÊáâË©≤Âú®ÈÄ£Êé•Â§±ÊïóÊôÇËøîÂõû false', async () => {
        mockedAxios.post.mockRejectedValue(new Error('Connection failed'))

        const result = await telegramClient.testConnection('123456789')

        expect(result).toBe(false)
      })
    })

    describe('getBotInfo', () => {
      it('ÊáâË©≤ËøîÂõû Bot Ë≥áË®ä', async () => {
        const botInfo = { id: 123456789, username: 'test_bot' }
        mockedAxios.get.mockResolvedValueOnce({ 
          data: { ok: true, result: botInfo } 
        })

        const result = await telegramClient.getBotInfo()

        expect(result).toEqual(botInfo)
        expect(mockedAxios.get).toHaveBeenCalledWith(
          'https://api.telegram.org/bottest-token/getMe'
        )
      })

      it('ÊáâË©≤ËôïÁêÜÂèñÂæó Bot Ë≥áË®äÂ§±Êïó', async () => {
        mockedAxios.get.mockRejectedValueOnce(new Error('API error'))

        await expect(telegramClient.getBotInfo())
          .rejects.toThrow('ÂèñÂæó Bot Ë≥áË®äÂ§±Êïó')
      })
    })
  })

  describe('‰æøÂà©ÂáΩÊï∏', () => {
    describe('sendArticlesToTelegram', () => {
      it('ÊáâË©≤Âª∫Á´ã Bot ÂØ¶‰æã‰∏¶ÁôºÈÄÅÊñáÁ´†', async () => {
        mockedAxios.post.mockResolvedValue({ data: { ok: true, result: {} } })

        await sendArticlesToTelegram('test-token', '123456789', mockArticles, 'Tech_Job')

        expect(mockedAxios.post).toHaveBeenCalled()
        const [url, payload] = mockedAxios.post.mock.calls[0]
        expect(url).toBe('https://api.telegram.org/bottest-token/sendMessage')
        expect(payload.chat_id).toBe('123456789')
      })
    })

    describe('testTelegramBot', () => {
      it('ÊáâË©≤Ê∏¨Ë©¶ Bot ÈÄ£Êé•', async () => {
        mockedAxios.post.mockResolvedValueOnce({ data: { ok: true, result: {} } })

        const result = await testTelegramBot('test-token', '123456789')

        expect(result).toBe(true)
        expect(mockedAxios.post).toHaveBeenCalledWith(
          'https://api.telegram.org/bottest-token/sendMessage',
          expect.objectContaining({
            chat_id: '123456789',
            text: 'ü§ñ Ê∏¨Ë©¶Ë®äÊÅØÔºöBot ÈÄ£Êé•Ê≠£Â∏∏ÔºÅ'
          })
        )
      })
    })
  })

  describe('TelegramBotError', () => {
    it('ÊáâË©≤Âª∫Á´ãÂÖ∑ÊúâÊ≠£Á¢∫Â±¨ÊÄßÁöÑÈåØË™§', () => {
      const error = new TelegramBotError('Ê∏¨Ë©¶ÈåØË™§', 400, false, true)

      expect(error.message).toBe('Ê∏¨Ë©¶ÈåØË™§')
      expect(error.statusCode).toBe(400)
      expect(error.retryable).toBe(false)
      expect(error.rateLimited).toBe(true)
      expect(error.name).toBe('TelegramBotError')
    })

    it('ÊáâË©≤È†êË®≠ retryable ÁÇ∫ true', () => {
      const error = new TelegramBotError('Ê∏¨Ë©¶ÈåØË™§')

      expect(error.retryable).toBe(true)
      expect(error.rateLimited).toBe(false)
    })
  })
})